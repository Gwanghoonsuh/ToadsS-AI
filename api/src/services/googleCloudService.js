const { Storage } = require('@google-cloud/storage');
const { PredictionServiceClient } = require('@google-cloud/aiplatform');
const { generateSystemPrompt, MARITIME_CONTEXT } = require('../prompts/system-prompt');

// Discovery Engine ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ï°∞Í±¥Î∂ÄÎ°ú Î°úÎìú
let DocumentServiceClient;
try {
    const { DocumentServiceClient: DiscoveryDocumentServiceClient } = require('@google-cloud/discoveryengine').v1;
    DocumentServiceClient = DiscoveryDocumentServiceClient;
} catch (error) {
    console.warn('‚ö†Ô∏è Discovery Engine client not available:', error.message);
    DocumentServiceClient = null;
}

// Vertex AI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ï°∞Í±¥Î∂ÄÎ°ú Î°úÎìú
let VertexAI;
try {
    const vertexai = require('@google-cloud/vertexai');
    VertexAI = vertexai.VertexAI;
} catch (error) {
    console.warn('‚ö†Ô∏è Vertex AI client not available:', error.message);
    VertexAI = null;
}

class GoogleCloudService {
    constructor() {
        console.log("üöÄ DEPLOYMENT CHECKPOINT: Running constructor v13 - Asia Northeast Region (Gemini Support) üöÄ");

        this.projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;
        this.region = process.env.GOOGLE_CLOUD_REGION || 'asia-northeast1';
        this.dataStoreId = process.env.VERTEX_AI_DATA_STORE_ID;
        
        console.log(`üåè Google Cloud Region: ${this.region}`);
        console.log(`üèóÔ∏è Project ID: ${this.projectId}`);
        
        // isTestModeÎäî ÌôòÍ≤Ω Î≥ÄÏàò Ï°¥Ïû¨ Ïó¨Î∂ÄÎ°úÎßå ÌåêÎã®
        this.isTestMode = !process.env.GOOGLE_APPLICATION_CREDENTIALS;

        if (this.isTestMode) {
            console.log('üîß Google Cloud Service running in TEST MODE.');
            return;
        }

        try {
            let credentials = null;
            const credentialsValue = process.env.GOOGLE_APPLICATION_CREDENTIALS;
            
            // JSON Î¨∏ÏûêÏó¥Ïù∏ÏßÄ ÌååÏùº Í≤ΩÎ°úÏù∏ÏßÄ ÌôïÏù∏
            if (credentialsValue.startsWith('{')) {
                // JSON Î¨∏ÏûêÏó¥Ïù∏ Í≤ΩÏö∞ ÌååÏã±Ìï¥ÏÑú credentials Í∞ùÏ≤¥Î°ú ÏÇ¨Ïö©
                try {
                    credentials = JSON.parse(credentialsValue);
                    
                    // private_keyÏùò Ï§ÑÎ∞îÍøà Î¨∏Ï†ú Ìï¥Í≤∞
                    if (credentials.private_key && typeof credentials.private_key === 'string') {
                        // Ï§ÑÎ∞îÍøàÏù¥ Ïù¥Ïä§ÏºÄÏù¥ÌîÑÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ ÏàòÏ†ï
                        credentials.private_key = credentials.private_key.replace(/\\n/g, '\n');
                        console.log('üîß Fixed private_key newline characters');
                    }
                    
                    console.log('‚úÖ Using JSON credentials from environment variable');
                    console.log(`   - Service account email: ${credentials.client_email}`);
                    console.log(`   - Project ID: ${credentials.project_id}`);
                } catch (parseError) {
                    console.error('‚ùå Failed to parse JSON credentials:', parseError.message);
                    throw parseError;
                }
            } else {
                console.log('‚úÖ Using file path credentials from environment variable');
                // ÌååÏùº Í≤ΩÎ°úÏù∏ Í≤ΩÏö∞ ÏûêÎèô Í∞êÏßÄ ÏÇ¨Ïö©
            }

            // credentialsÍ∞Ä ÏûàÏúºÎ©¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï†ÑÎã¨, ÏóÜÏúºÎ©¥ ÏûêÎèô Í∞êÏßÄ
            if (credentials) {
                this.storage = new Storage({ 
                    credentials: credentials,
                    projectId: this.projectId 
                });
                
                if (VertexAI) {
                    this.vertexAI = new VertexAI({ 
                        project: this.projectId, 
                        location: this.region,
                        googleAuthOptions: { credentials: credentials }
                    });
                }
                
                if (DocumentServiceClient) {
                    this.documentClient = new DocumentServiceClient({
                        credentials: credentials,
                        projectId: this.projectId
                    });
                }

                this.predictionClient = new PredictionServiceClient({
                    apiEndpoint: `${this.region}-aiplatform.googleapis.com`,
                    credentials: credentials,
                    projectId: this.projectId
                });
                
                console.log('‚úÖ All Google Cloud clients initialized with JSON credentials.');
            } else {
                // ÌååÏùº Í≤ΩÎ°ú Î∞©Ïãù - ÏûêÎèô Í∞êÏßÄ
                this.storage = new Storage();
                
                if (VertexAI) {
                    this.vertexAI = new VertexAI({ project: this.projectId, location: this.region });
                }
                
                if (DocumentServiceClient) {
                    this.documentClient = new DocumentServiceClient();
                }

                this.predictionClient = new PredictionServiceClient({
                    apiEndpoint: `${this.region}-aiplatform.googleapis.com`,
                });
                
                console.log('‚úÖ All Google Cloud clients initialized with file path credentials.');
            }

        } catch (error) {
            console.error('‚ùå CRITICAL: Google Cloud client initialization FAILED.', error);
            this.isTestMode = true; // Ïã§Ìå® Ïãú ÏïàÏ†ÑÌïòÍ≤å ÌÖåÏä§Ìä∏ Î™®ÎìúÎ°ú Ï†ÑÌôò
        }
    }

    async getCustomerBucket(customerId) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Skipping bucket operations');
            return null;
        }

        // Í≥µÏú† Î≤ÑÌÇ∑ ÏÇ¨Ïö© (Î™®Îì† Í≥†Í∞ùÏù¥ Í∞ôÏùÄ Î≤ÑÌÇ∑, Ìè¥ÎçîÎ°ú Íµ¨Î∂Ñ)
        const bucketName = 'toads-shipping-ai-docs';
        const bucket = this.storage.bucket(bucketName);

        try {
            const [exists] = await bucket.exists();
            if (!exists) {
                console.log(`üì¶ Creating shared bucket: ${bucketName}`);
                await bucket.create({
                    location: this.region,
                    storageClass: 'STANDARD'
                });
                console.log(`‚úÖ Shared bucket created: ${bucketName}`);
            } else {
                console.log(`üìÅ Using shared bucket: ${bucketName} for customer ${customerId}`);
            }
        } catch (error) {
            console.error(`‚ùå Error managing shared bucket ${bucketName}:`, error);
            throw new Error(`Failed to access bucket: ${error.message}`);
        }

        return bucket;
    }

    async listFiles(customerId) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Returning empty file list');
            return [];
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);
            if (!bucket) {
                return [];
            }

            const customerFolder = `customer-${customerId}/`;
            
            // Í≥†Í∞ùÎ≥Ñ Ìè¥ÎçîÏóêÏÑúÎßå ÌååÏùº Ï°∞Ìöå (Îç∞Ïù¥ÌÑ∞ Í≤©Î¶¨)
            const [files] = await bucket.getFiles({ prefix: customerFolder });

            return files.map(file => ({
                name: file.name,
                size: file.metadata.size,
                created: file.metadata.timeCreated,
                updated: file.metadata.updated,
                contentType: file.metadata.contentType,
                originalName: file.metadata.originalName,
                customerId: file.metadata.customerId
            }));
        } catch (error) {
            console.error(`‚ùå Error listing files for customer ${customerId}:`, error);
            throw new Error(`Failed to list files: ${error.message}`);
        }
    }

    async uploadFile(customerId, file, originalName) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Skipping file upload');
            return {
                fileName: `test-${originalName}`,
                gcsUri: `gs://test-bucket/test-${originalName}`,
                timestamp: Date.now(),
                customerFolder: `customer-${customerId}`
            };
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);
            if (!bucket) {
                throw new Error('Bucket not available in test mode');
            }
            
            // Í≥†Í∞ùÎ≥Ñ Ìè¥Îçî Íµ¨Ï°∞ ÏÉùÏÑ±: customer-{customerId}/timestamp-randomstring-filename
            const timestamp = Date.now();
            const randomString = Math.random().toString(36).substring(2, 8);
            const customerFolder = `customer-${customerId}`;
            const fileName = `${customerFolder}/${timestamp}-${randomString}-${originalName}`;
            const fileUpload = bucket.file(fileName);

            await fileUpload.save(file.buffer, {
                metadata: {
                    contentType: file.mimetype,
                    originalName: originalName,
                    customerId: customerId.toString(),
                    uploadTimestamp: timestamp.toString()
                }
            });

            console.log(`‚úÖ File uploaded: ${fileName}`);
            return {
                fileName,
                gcsUri: `gs://${bucket.name}/${fileName}`,
                timestamp,
                customerFolder
            };
        } catch (error) {
            console.error(`‚ùå Error uploading file ${originalName}:`, error);
            throw new Error(`Failed to upload file: ${error.message}`);
        }
    }

    async deleteFile(customerId, fileName) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Skipping file deletion');
            return { success: true, fileName };
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);
            if (!bucket) {
                throw new Error('Bucket not available in test mode');
            }
            const file = bucket.file(fileName);
            
            // ÌååÏùºÏù¥ Ìï¥Îãπ Í≥†Í∞ùÏùò Ìè¥ÎçîÏóê ÏûàÎäîÏßÄ ÌôïÏù∏ (Î≥¥Ïïà)
            if (!fileName.startsWith(`customer-${customerId}/`)) {
                throw new Error(`Access denied: File does not belong to customer ${customerId}`);
            }
            
            await file.delete();
            console.log(`‚úÖ File deleted: ${fileName}`);
            return { success: true, fileName };
        } catch (error) {
            console.error(`‚ùå Error deleting file ${fileName}:`, error);
            throw new Error(`Failed to delete file: ${error.message}`);
        }
    }

    async searchDocuments(customerId, query, maxResults = 5) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Returning empty search results');
            return [];
        }

        try {
            console.log(`üîç Searching documents for customer ${customerId} with query: "${query}"`);
            
            // Í≥†Í∞ùÎ≥Ñ Î¨∏ÏÑúÎßå Í≤ÄÏÉâÌïòÍ∏∞ ÏúÑÌï¥ StorageÏóêÏÑú Ìï¥Îãπ Í≥†Í∞ù Î¨∏ÏÑú Î™©Î°ù Ï°∞Ìöå
            const bucket = await this.getCustomerBucket(customerId);
            if (!bucket) {
                return [];
            }

            const customerFolder = `customer-${customerId}/`;
            
            // Í≥†Í∞ùÎ≥Ñ Ìè¥ÎçîÏóêÏÑúÎßå ÌååÏùº Ï°∞Ìöå (Îç∞Ïù¥ÌÑ∞ Í≤©Î¶¨ Î≥¥Ïû•)
            const [files] = await bucket.getFiles({ prefix: customerFolder });
            
            if (files.length === 0) {
                console.log(`üìÇ No documents found for customer ${customerId}`);
                return [];
            }

            console.log(`üìÇ Found ${files.length} documents for customer ${customerId}`);
            
            // ÌòÑÏû¨Îäî Î™®Îì† Í≥†Í∞ù Î¨∏ÏÑúÎ•º Î∞òÌôò (Ïã§Ï†úÎ°úÎäî Í≤ÄÏÉâ ÏøºÎ¶¨ Í∏∞Î∞ò ÌïÑÌÑ∞ÎßÅ ÌïÑÏöî)
            // TODO: Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Vertex AI SearchÎÇò EmbeddingÏùÑ ÏÇ¨Ïö©Ìïú ÏùòÎØ∏Ï†Å Í≤ÄÏÉâ Íµ¨ÌòÑ
            const searchResults = files.map((file, index) => {
                const originalName = file.metadata.originalName || file.name;
                const displayName = originalName.replace(/^customer-\d+\/\d+-[a-z0-9]+-/, '');
                
                return {
                    id: `${customerId}-${index}`,
                    title: displayName,
                    content: `${displayName}ÏóêÏÑú Í≤ÄÏÉâÎêú ÎÇ¥Ïö©ÏûÖÎãàÎã§. Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Î¨∏ÏÑú ÎÇ¥Ïö©ÏùÑ ÌååÏã±ÌïòÏó¨ Ï†úÍ≥µÌï©ÎãàÎã§.`,
                    uri: `gs://${bucket.name}/${file.name}`,
                    customerId: customerId, // Î≥¥Ïïà: Î∞òÎìúÏãú Ìï¥Îãπ Í≥†Í∞ù ID Ìè¨Ìï®
                    fileName: file.name,
                    size: file.metadata.size,
                    contentType: file.metadata.contentType
                };
            }).slice(0, maxResults);

            // Î≥¥Ïïà Í≤ÄÏ¶ù: Î™®Îì† Í≤∞Í≥ºÍ∞Ä Ìï¥Îãπ Í≥†Í∞ùÏùò Í≤ÉÏù∏ÏßÄ ÌôïÏù∏
            const invalidResults = searchResults.filter(result => 
                !result.fileName.startsWith(`customer-${customerId}/`)
            );
            
            if (invalidResults.length > 0) {
                console.error(`üö® Security violation: Found documents not belonging to customer ${customerId}`);
                throw new Error(`Access denied: Invalid document access attempt`);
            }

            console.log(`‚úÖ Returning ${searchResults.length} secure search results for customer ${customerId}`);
            return searchResults;

        } catch (error) {
            console.error(`‚ùå Error searching documents for customer ${customerId}:`, error);
            
            // Î≥¥ÏïàÏÉÅ ÎØºÍ∞êÌïú Ïò§Î•ò Ï†ïÎ≥¥Îäî Ïà®ÍπÄ
            if (error.message.includes('Access denied')) {
                throw error; // Î≥¥Ïïà Ïò§Î•òÎäî Í∑∏ÎåÄÎ°ú Ï†ÑÌåå
            }
            
            throw new Error('Document search failed');
        }
    }

    async generateAIResponse(query, context, customerId) {
        if (this.isTestMode) {
            console.log('üîß Test mode: Returning mock AI response');
            return {
                response: "Ïù¥Í≤ÉÏùÄ ÌÖåÏä§Ìä∏ Î™®Îìú ÏùëÎãµÏûÖÎãàÎã§. Google Cloud Ïù∏Ï¶ùÏù¥ ÏÑ§Ï†ïÎêòÎ©¥ Ïã§Ï†ú AI ÏùëÎãµÏù¥ Ï†úÍ≥µÎê©ÎãàÎã§.",
                mock: true,
                reason: 'Test mode enabled'
            };
        }

        try {
            // Vertex AI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Í∞ÄÏö©ÏÑ± Í≤ÄÏÇ¨
            if (!VertexAI || !this.vertexAI) {
                console.log('‚ö†Ô∏è Vertex AI not available or not initialized, using mock response');
                return {
                    response: "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ AI ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
                    mock: true,
                    reason: !VertexAI ? 'Library not loaded' : 'Client not initialized'
                };
            }

            // Vertex AI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î©îÏÑúÎìú Ï°¥Ïû¨ ÌôïÏù∏
            if (typeof this.vertexAI.getGenerativeModel !== 'function') {
                console.error('‚ùå getGenerativeModel method not available');
                console.error('üîç Available methods:', Object.getOwnPropertyNames(this.vertexAI));
                return {
                    response: "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ AI ÏÑúÎπÑÏä§ ÏÑ§Ï†ïÏóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥Ï£ºÏÑ∏Ïöî.",
                    mock: true,
                    reason: 'Method not available'
                };
            }

            // Í≥†Í∞ùÏÇ¨ Ï†ïÎ≥¥ (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî DBÏóêÏÑú Ï°∞Ìöå)
            const customerName = `Í≥†Í∞ùÏÇ¨-${customerId}`;
            
            // Î≥¥Ïïà Í≤ÄÏ¶ù: contextÏóê Îã§Î•∏ Í≥†Í∞ù Ï†ïÎ≥¥Í∞Ä Ìè¨Ìï®ÎêòÏßÄ ÏïäÏïòÎäîÏßÄ ÌôïÏù∏
            if (context && context.includes(`customer-`) && !context.includes(`customer-${customerId}`)) {
                console.error(`üö® Security violation: Context contains other customer data for customer ${customerId}`);
                throw new Error('Access denied: Invalid context data');
            }
            
            // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ± (Í≥†Í∞ùÎ≥Ñ Í≤©Î¶¨ Í∞ïÏ°∞)
            let systemPrompt;
            try {
                systemPrompt = generateSystemPrompt(customerName, context, query) + 
                    `\n\n‚ö†Ô∏è Ï§ëÏöî Î≥¥Ïïà ÏßÄÏπ®: ÎãπÏã†ÏùÄ Ïò§ÏßÅ Í≥†Í∞ùÏÇ¨-${customerId}Ïùò Î¨∏ÏÑúÎßåÏùÑ Ï∞∏Ï°∞Ìï¥Ïïº Ìï©ÎãàÎã§. Îã§Î•∏ Í≥†Í∞ùÏÇ¨Ïùò Ï†ïÎ≥¥Îäî Ï†àÎåÄÎ°ú ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò Ïñ∏Í∏âÌï¥ÏÑúÎäî Ïïà Îê©ÎãàÎã§.`;
                
                // ÌîÑÎ°¨ÌîÑÌä∏ Í∏∏Ïù¥ Í≤ÄÏ¶ù (ÌÜ†ÌÅ∞ Ï†úÌïú Í≥†Î†§)
                if (systemPrompt.length > 30000) { // ÎåÄÎûµ 15K ÌÜ†ÌÅ∞ ÌïúÎèÑ
                    console.warn(`‚ö†Ô∏è System prompt too long (${systemPrompt.length} chars), truncating context`);
                    const truncatedContext = context.substring(0, 5000) + '\n[...ÎÇ¥Ïö© ÏÉùÎûµ...]';
                    systemPrompt = generateSystemPrompt(customerName, truncatedContext, query) + 
                        `\n\n‚ö†Ô∏è Ï§ëÏöî Î≥¥Ïïà ÏßÄÏπ®: ÎãπÏã†ÏùÄ Ïò§ÏßÅ Í≥†Í∞ùÏÇ¨-${customerId}Ïùò Î¨∏ÏÑúÎßåÏùÑ Ï∞∏Ï°∞Ìï¥Ïïº Ìï©ÎãàÎã§.`;
                }
            } catch (promptError) {
                console.error('‚ùå Error generating system prompt:', promptError);
                throw new Error('Failed to generate system prompt');
            }
            
            // Vertex AI Gemini Î™®Îç∏ ÏÇ¨Ïö© (preview Ï†úÍ±∞, ÏïàÏ†ïÏ†ÅÏù∏ Î™®Îç∏ ÏÇ¨Ïö©)
            const model = this.vertexAI.getGenerativeModel({
                model: "gemini-1.5-flash-001", // Îπ†Î•¥Í≥† ÏïàÏ†ïÏ†ÅÏù∏ Î≤ÑÏ†Ñ ÏÇ¨Ïö©
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    maxOutputTokens: 2048,
                    temperature: 0.2,
                    topP: 0.8,
                    topK: 40
                }
            });

            console.log(`ü§ñ Generating AI response for customer ${customerId}`);
            console.log(`üìù Query: ${query}`);
            console.log(`üìö Context length: ${context.length} characters`);
            console.log(`üîß Model: ${model.model}, Region: ${this.region}`);

            // AI ÏùëÎãµ ÏÉùÏÑ± (Ïò§Î•ò Î∞úÏÉù Ïãú Ïû¨ÏãúÎèÑ Î°úÏßÅ)
            let result;
            let usedFallback = false;
            
            try {
                result = await model.generateContent({
                    contents: [
                        {
                            role: "user",
                            parts: [{ text: query }]
                        }
                    ]
                });
            } catch (modelError) {
                console.warn('‚ö†Ô∏è Primary model failed, trying fallback model...', modelError.message);
                
                try {
                    // Fallback to basic gemini-1.0-pro model (systemInstruction ÏóÜÏù¥)
                    const fallbackModel = this.vertexAI.getGenerativeModel({
                        model: "gemini-1.0-pro",
                        generationConfig: {
                            maxOutputTokens: 2048,
                            temperature: 0.2,
                            topP: 0.8
                        }
                    });
                    
                    // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏Î•º ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄÏóê Ìè¨Ìï®
                    const fullPrompt = `${systemPrompt}\n\n---\n\nÏÇ¨Ïö©Ïûê ÏßàÎ¨∏: ${query}`;
                    
                    result = await fallbackModel.generateContent({
                        contents: [
                            {
                                role: "user", 
                                parts: [{ text: fullPrompt }]
                            }
                        ]
                    });
                    
                    usedFallback = true;
                    console.log('‚úÖ Fallback model response generated successfully');
                } catch (fallbackError) {
                    console.error('‚ùå Both primary and fallback models failed');
                    throw new Error(`AI generation failed: Primary (${modelError.message}), Fallback (${fallbackError.message})`);
                }
            }

            // ÏùëÎãµ Í≤ÄÏ¶ù Î∞è Ï∂îÏ∂ú
            if (!result || !result.response) {
                throw new Error('No response received from Vertex AI');
            }

            if (!result.response.candidates || result.response.candidates.length === 0) {
                throw new Error('No candidates in Vertex AI response');
            }

            const candidate = result.response.candidates[0];
            
            // ÏïàÏ†Ñ ÌïÑÌÑ∞ ÌôïÏù∏
            if (candidate.finishReason === 'SAFETY') {
                console.warn('‚ö†Ô∏è Response blocked by safety filter');
                return {
                    response: "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÏïàÏ†Ñ Ï†ïÏ±ÖÏúºÎ°ú Ïù∏Ìï¥ ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Î∞©ÏãùÏúºÎ°ú ÏßàÎ¨∏Ìï¥Ï£ºÏÑ∏Ïöî.",
                    customerName: customerName,
                    contextUsed: context.length > 0,
                    safetyFiltered: true
                };
            }

            if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                throw new Error('No content in Vertex AI response candidate');
            }

            const aiResponse = candidate.content.parts[0].text;
            
            console.log(`‚úÖ AI response generated successfully${usedFallback ? ' (using fallback model)' : ''}`);
            return {
                response: aiResponse,
                customerName: customerName,
                contextUsed: context.length > 0,
                usedFallback: usedFallback
            };

        } catch (error) {
            console.error(`‚ùå Error generating AI response:`, error);
            console.error(`üîç Error details - Project: ${this.projectId}, Region: ${this.region}`);
            
            let fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ Í∏∞Ïà†Ï†ÅÏù∏ Î¨∏Ï†úÎ°ú ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.";
            
            // Íµ¨Ï≤¥Ï†ÅÏù∏ Ïò§Î•òÏóê Îî∞Î•∏ Ï†ÅÏ†àÌïú fallback Î©îÏãúÏßÄ
            if (error.message.includes('GoogleAuthError') || error.message.includes('Unable to authenticate')) {
                fallbackMessage = "ÌòÑÏû¨ AI ÏÑúÎπÑÏä§ Ïù∏Ï¶ùÏóê Î¨∏Ï†úÍ∞Ä ÏûàÏñ¥ ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.";
                console.error(`üö® Google Auth Error - Project: ${this.projectId}, Region: ${this.region}`);
            } else if (error.message.includes('404') || error.message.includes('Not Found')) {
                fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ AI Î™®Îç∏ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏßÄÏó≠ ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÍ≥† ÏûàÏäµÎãàÎã§.";
                console.error(`üö® Model availability issue - Region: ${this.region}, Model: gemini-1.5-flash`);
            } else if (error.message.includes('quota')) {
                fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ ÏÑúÎπÑÏä§ Ïù¥Ïö©ÎüâÏù¥ ÎßéÏïÑ Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.";
            } else if (error.message.includes('authentication') || error.message.includes('credentials')) {
                fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÌòÑÏû¨ Ïù∏Ï¶ù Î¨∏Ï†úÎ°ú ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥Ï£ºÏÑ∏Ïöî.";
            } else if (error.message.includes('network') || error.message.includes('timeout')) {
                fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå ÎÑ§Ìä∏ÏõåÌÅ¨ Î¨∏Ï†úÎ°ú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.";
            } else if (error.message.includes('model') || error.message.includes('candidates')) {
                fallbackMessage = "Ï£ÑÏÜ°ÌïòÏßÄÎßå AI Î™®Îç∏ÏóêÏÑú Ï†ÅÏ†àÌïú ÏùëÎãµÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Î∞©ÏãùÏúºÎ°ú ÏßàÎ¨∏Ìï¥Ï£ºÏÑ∏Ïöî.";
            }
            
            // Ïã§Ìå® Ïãú fallback ÏùëÎãµ
            return {
                response: fallbackMessage,
                error: error.message,
                fallback: true,
                customerName: `Í≥†Í∞ùÏÇ¨-${customerId}`,
                contextUsed: context.length > 0
            };
        }
    }

    async addDocumentToDataStore(customerId, gcsUri, fileName) {
        // Discovery EngineÏù¥ ÏÇ¨Ïö© Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞ Ïä§ÌÇµ
        if (!DocumentServiceClient) {
            console.log('‚ö†Ô∏è Discovery Engine not available, skipping document indexing');
            return { success: true, skipped: true };
        }
        
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Discovery Engine APIÎ•º ÏÇ¨Ïö©
        console.log(`üìö Adding document to data store: ${fileName} for customer ${customerId}`);
        return { success: true, message: 'Document added to data store' };
    }

    async removeDocumentFromDataStore(customerId, fileName) {
        // Discovery EngineÏù¥ ÏÇ¨Ïö© Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞ Ïä§ÌÇµ
        if (!DocumentServiceClient) {
            console.log('‚ö†Ô∏è Discovery Engine not available, skipping document removal');
            return { success: true, skipped: true };
        }
        
        try {
            // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Discovery Engine APIÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î¨∏ÏÑú ÏÇ≠Ï†ú
            console.log(`üóëÔ∏è Removing document from data store: ${fileName} for customer ${customerId}`);
            
            // TODO: Discovery Engine APIÎ•º ÏÇ¨Ïö©Ìïú Ïã§Ï†ú Î¨∏ÏÑú ÏÇ≠Ï†ú Íµ¨ÌòÑ
            // const documentId = this.generateDocumentId(fileName);
            // await this.documentClient.deleteDocument({
            //     name: `projects/${this.projectId}/locations/${this.region}/dataStores/${this.dataStoreId}/branches/default_branch/documents/${documentId}`
            // });
            
            console.log(`‚úÖ Document removed from data store: ${fileName}`);
            return { success: true, message: 'Document removed from data store' };
        } catch (error) {
            console.error(`‚ùå Error removing document from data store: ${error.message}`);
            // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ†Ïñ¥ ÏÇ≠Ï†ú Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏùå (ÌååÏùºÏùÄ Ïù¥ÎØ∏ ÏÇ≠Ï†úÎê®)
            return { success: false, error: error.message, warning: 'File deleted but data store cleanup failed' };
        }
    }

    async initializeCustomer(customerId) {
        console.log(`üìÅ Initializing customer folder for customer ${customerId}...`);
        
        if (this.isTestMode) {
            console.log('üîß Test mode: Skipping customer folder initialization');
            return { success: true, message: 'Test mode - customer folder initialization skipped' };
        }

        try {
            // Î©îÏù∏ Í≥µÏú† Î≤ÑÌÇ∑ ÏÇ¨Ïö© (toads-shipping-ai-docs)
            const bucketName = 'toads-shipping-ai-docs';
            const bucket = this.storage.bucket(bucketName);
            
            // Î≤ÑÌÇ∑ Ï°¥Ïû¨ ÌôïÏù∏
            const [bucketExists] = await bucket.exists();
            if (!bucketExists) {
                console.log(`üì¶ Bucket ${bucketName} does not exist. Creating...`);
                await bucket.create({
                    location: this.region,
                    storageClass: 'STANDARD'
                });
                console.log(`‚úÖ Bucket created: ${bucketName}`);
            }

            // Í≥†Í∞ùÎ≥Ñ Ìè¥Îçî ÏÉùÏÑ± (Îπà ÌååÏùºÎ°ú Ìè¥Îçî Íµ¨Ï°∞ ÏÉùÏÑ±)
            const customerFolder = `customer-${customerId}/`;
            const initFile = `${customerFolder}.init`;
            
            const file = bucket.file(initFile);
            const [fileExists] = await file.exists();
            
            if (!fileExists) {
                await file.save('', {
                    metadata: {
                        contentType: 'text/plain',
                        customerId: customerId.toString(),
                        purpose: 'folder_initialization'
                    }
                });
                console.log(`‚úÖ Customer folder created: ${customerFolder}`);
            } else {
                console.log(`üìÅ Customer folder already exists: ${customerFolder}`);
            }

            return { success: true, message: `Customer folder initialized: ${customerFolder}` };
        } catch (error) {
            console.error(`‚ùå Error initializing customer folder for ${customerId}:`, error);
            // Ìè¥Îçî Ï¥àÍ∏∞Ìôî Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏùå (Î°úÍ∑∏Ïù∏ÏùÄ Í≥ÑÏÜç ÏßÑÌñâ)
            return { success: false, error: error.message, warning: 'Customer folder initialization failed but login continues' };
        }
    }
}

module.exports = new GoogleCloudService();