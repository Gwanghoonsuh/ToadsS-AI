const { Storage } = require('@google-cloud/storage');
const { PredictionServiceClient } = require('@google-cloud/aiplatform');
const { generateSystemPrompt, MARITIME_CONTEXT } = require('../prompts/system-prompt');
const path = require('path');

// Discovery Engine ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ï°∞Í±¥Î∂ÄÎ°ú Î°úÎìú
let DocumentServiceClient;
try {
    const { DocumentServiceClient: DiscoveryDocumentServiceClient } = require('@google-cloud/discoveryengine').v1;
    DocumentServiceClient = DiscoveryDocumentServiceClient;
    console.log('‚úÖ Discovery Engine client loaded successfully');
} catch (error) {
    console.warn('‚ö†Ô∏è Discovery Engine client not available:', error.message);
    DocumentServiceClient = null;
}

// Vertex AI ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ï°∞Í±¥Î∂ÄÎ°ú Î°úÎìú
let VertexAI;
try {
    const vertexai = require('@google-cloud/vertexai');
    VertexAI = vertexai.VertexAI;
    console.log('‚úÖ Vertex AI client loaded successfully');
} catch (error) {
    console.warn('‚ö†Ô∏è Vertex AI client not available:', error.message);
    VertexAI = null;
}

class GoogleCloudService {
    constructor() {
        // Ïù¥ Î°úÍ∑∏Îäî ÏÉà ÏΩîÎìúÍ∞Ä Ïã§ÌñâÎêòÍ≥† ÏûàÎã§Îäî Ï¶ùÍ±∞ÏûÖÎãàÎã§.
        console.log("üöÄ DEPLOYMENT VERSION: v4 - FINAL (AUTO AUTH) üöÄ");

        this.projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;
        this.region = process.env.GOOGLE_CLOUD_REGION || 'asia-northeast3';
        this.dataStoreId = process.env.VERTEX_AI_DATA_STORE_ID;

        this.isTestMode = !process.env.GOOGLE_APPLICATION_CREDENTIALS;

        // In-memory storage for test mode
        this.testStorage = new Map(); // customerId -> files array

        if (this.isTestMode) {
            console.log('üîß Google Cloud Service running in TEST MODE.');
            return;
        }

        try {
            // GOOGLE_APPLICATION_CREDENTIALSÍ∞Ä JSON Î¨∏ÏûêÏó¥Ïù∏ Í≤ΩÏö∞ Ï≤òÎ¶¨
            let credentials = null;
            if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {
                try {
                    // JSON Î¨∏ÏûêÏó¥Ïù∏ÏßÄ ÌôïÏù∏
                    credentials = JSON.parse(process.env.GOOGLE_APPLICATION_CREDENTIALS);
                    console.log('‚úÖ Using JSON credentials from environment variable');
                } catch (e) {
                    // ÌååÏùº Í≤ΩÎ°úÏù∏ Í≤ΩÏö∞
                    console.log('‚úÖ Using file path credentials from environment variable');
                }
            }

            // Storage ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
            if (credentials) {
                this.storage = new Storage({ credentials });
            } else {
                this.storage = new Storage();
            }

            if (VertexAI) {
                if (credentials) {
                    this.vertexAI = new VertexAI({
                        project: this.projectId,
                        location: this.region,
                        credentials
                    });
                } else {
                    this.vertexAI = new VertexAI({
                        project: this.projectId,
                        location: this.region
                    });
                }
            }

            if (DocumentServiceClient) {
                if (credentials) {
                    this.documentClient = new DocumentServiceClient({ credentials });
                } else {
                    this.documentClient = new DocumentServiceClient();
                }
            }

            if (credentials) {
                this.predictionClient = new PredictionServiceClient({
                    apiEndpoint: `${this.region}-aiplatform.googleapis.com`,
                    credentials
                });
            } else {
                this.predictionClient = new PredictionServiceClient({
                    apiEndpoint: `${this.region}-aiplatform.googleapis.com`,
                });
            }

            console.log('‚úÖ All Google Cloud clients initialized with proper credentials.');

        } catch (error) {
            console.error('‚ùå CRITICAL: Google Cloud client initialization FAILED.', error);
            this.isTestMode = true; // Ïã§Ìå® Ïãú ÌÖåÏä§Ìä∏ Î™®ÎìúÎ°ú Ï†ÑÌôò
        }
    }

    /**
     * Get or create customer-specific storage bucket
     */
    async getCustomerBucket(customerId) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Getting bucket for customer ${customerId}`);
            return { name: `test-bucket-${customerId}` };
        }

        if (!this.storage) {
            console.error('‚ùå Google Cloud Storage client not initialized');
            console.log('üîß Switching to TEST MODE due to missing storage client');
            this.isTestMode = true;
            return { name: `test-bucket-${customerId}` };
        }

        const bucketName = `toads-ai-agent-${customerId}`;
        console.log(`ü™£ Getting bucket: ${bucketName}`);
        console.log(`üìã Project ID: ${this.projectId}`);
        console.log(`üåè Region: ${this.region}`);
        console.log(`üë§ Customer ID: ${customerId}`);

        try {
            const bucket = this.storage.bucket(bucketName);
            const [exists] = await bucket.exists();

            if (!exists) {
                console.log(`üì¶ Creating new bucket: ${bucketName}`);
                await bucket.create({
                    location: this.region,
                    storageClass: 'STANDARD',
                    uniformBucketLevelAccess: true,
                });

                console.log(`‚úÖ Created bucket: ${bucketName}`);
            } else {
                console.log(`‚úÖ Bucket exists: ${bucketName}`);
            }

            return bucket;
        } catch (error) {
            console.error('‚ùå Error getting customer bucket:', error);
            console.error('‚ùå Error details:', {
                name: error.name,
                message: error.message,
                code: error.code,
                status: error.status,
                details: error.details,
                stack: error.stack
            });
            console.error('‚ùå Context details:', {
                customerId,
                bucketName,
                projectId: this.projectId,
                region: this.region,
                isTestMode: this.isTestMode
            });

            // Check for specific error types
            if (error.code === 403) {
                console.error('‚ùå PERMISSION DENIED: Service account lacks storage.objects.create permission');
                console.error('‚ùå Please check IAM roles for the service account');
            } else if (error.code === 404) {
                console.error('‚ùå BUCKET NOT FOUND: Bucket does not exist or project ID is incorrect');
                console.error('‚ùå Please verify project ID and bucket naming');
            } else if (error.code === 400) {
                console.error('‚ùå BAD REQUEST: Invalid bucket name or configuration');
                console.error('‚ùå Please check bucket name format and region');
            }

            throw new Error(`Failed to access storage bucket for customer ${customerId}: ${error.message}`);
        }
    }

    /**
     * Upload file to customer bucket
     */
    // Helper function to create URL-safe filename
    createSafeFileName(originalName) {
        // Extract file extension
        const lastDotIndex = originalName.lastIndexOf('.');
        const nameWithoutExt = lastDotIndex > 0 ? originalName.substring(0, lastDotIndex) : originalName;
        const extension = lastDotIndex > 0 ? originalName.substring(lastDotIndex) : '';

        // Create URL-safe filename with timestamp and random suffix to prevent conflicts
        const timestamp = Date.now();
        const randomSuffix = Math.random().toString(36).substring(2, 8); // 6-character random string

        // Use the original Korean filename directly (no more Base64 encoding)
        // Google Cloud Storage now supports Korean filenames properly
        const safeName = `${timestamp}-${randomSuffix}-${nameWithoutExt}${extension}`;

        console.log('üìÅ Creating safe filename:', {
            originalName,
            nameWithoutExt,
            extension,
            timestamp,
            randomSuffix,
            safeName
        });

        return safeName;
    }

    async uploadFile(customerId, file, originalName) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Uploading file ${originalName} for customer ${customerId}`);
            const fileName = this.createSafeFileName(originalName);

            // Store file info in memory
            if (!this.testStorage.has(customerId)) {
                this.testStorage.set(customerId, []);
            }

            const fileInfo = {
                name: fileName,
                originalName: originalName, // Keep original name for display
                size: file.size,
                timeCreated: new Date().toISOString(),
                contentType: file.mimetype
            };

            this.testStorage.get(customerId).push(fileInfo);
            console.log(`üîß TEST MODE: File stored in memory. Total files for ${customerId}: ${this.testStorage.get(customerId).length}`);

            return {
                fileName,
                gcsUri: `gs://test-bucket-${customerId}/${fileName}`,
                bucketName: `test-bucket-${customerId}`
            };
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);

            // Create safe filename with timestamp and random suffix
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            const ext = path.extname(originalName);
            const nameWithoutExt = path.basename(originalName, ext);
            const fileName = `${timestamp}-${randomSuffix}-${nameWithoutExt}${ext}`;

            // Create customer-specific folder path
            const customerFolder = `customer-${customerId}`;
            const filePath = `${customerFolder}/${fileName}`;
            const fileUpload = bucket.file(filePath);

            console.log('üìÅ File upload path:', {
                customerId,
                customerFolder,
                fileName,
                fullPath: filePath,
                originalName: originalName
            });

            // Use memory buffer for binary data integrity
            if (!file.buffer) {
                throw new Error('No file buffer available - memory storage required for binary files');
            }

            const uploadData = file.buffer;
            console.log('üì§ Uploading from memory buffer, size:', uploadData.length, 'bytes');

            // Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ
            const memoryUsage = process.memoryUsage();
            console.log('üß† Memory usage:', {
                rss: Math.round(memoryUsage.rss / 1024 / 1024) + 'MB',
                heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + 'MB',
                heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + 'MB',
                external: Math.round(memoryUsage.external / 1024 / 1024) + 'MB'
            });

            await fileUpload.save(uploadData, {
                metadata: {
                    contentType: file.mimetype,
                    metadata: {
                        originalName: originalName,
                        customerId: customerId,
                        uploadedAt: new Date().toISOString()
                    }
                }
            });

            const gcsUri = `gs://${bucket.name}/${filePath}`;
            console.log(`‚úÖ File uploaded successfully: ${gcsUri}`);
            console.log(`üìä Upload stats: ${uploadData.length} bytes, ${file.mimetype}`);

            return {
                fileName: filePath, // Return full path including customer folder
                originalFileName: fileName, // Return just the filename without folder
                gcsUri,
                bucketName: bucket.name,
                customerFolder
            };
        } catch (error) {
            console.error('‚ùå Error uploading file:', error);

            // Clean up temporary file on error
            if (file.path) {
                try {
                    const fs = require('fs');
                    if (fs.existsSync(file.path)) {
                        fs.unlinkSync(file.path);
                        console.log('üóëÔ∏è Temporary file cleaned up after error:', file.path);
                    }
                } catch (cleanupError) {
                    console.warn('‚ö†Ô∏è Failed to clean up temporary file after error:', cleanupError.message);
                }
            }

            // Provide more specific error messages
            if (error.code === 403) {
                throw new Error('Permission denied: Check Google Cloud Storage permissions');
            } else if (error.code === 404) {
                throw new Error('Bucket not found: Check bucket configuration');
            } else if (error.message.includes('ENOENT')) {
                throw new Error('File not found: Check file path');
            } else {
                throw new Error(`Failed to upload file: ${error.message}`);
            }
        }
    }

    /**
     * Delete file from customer bucket
     */
    async deleteFile(customerId, fileName) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Deleting file ${fileName} for customer ${customerId}`);

            // Remove file from memory storage
            if (this.testStorage.has(customerId)) {
                const files = this.testStorage.get(customerId);
                const index = files.findIndex(file => file.name === fileName);
                if (index !== -1) {
                    files.splice(index, 1);
                    console.log(`üîß TEST MODE: File deleted from memory. Remaining files for ${customerId}: ${files.length}`);
                }
            }

            return { success: true };
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);

            // If fileName doesn't include customer folder, add it
            let fullPath = fileName;
            if (!fileName.startsWith(`customer-${customerId}/`)) {
                const customerFolder = `customer-${customerId}`;
                fullPath = `${customerFolder}/${fileName}`;
            }

            const file = bucket.file(fullPath);
            await file.delete();
            console.log(`File deleted: ${fullPath}`);
            return { success: true };
        } catch (error) {
            console.error('Error deleting file:', error);
            throw new Error(`Failed to delete file: ${error.message}`);
        }
    }

    /**
     * List files in customer bucket
     */
    async listFiles(customerId) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Listing files for customer ${customerId}`);

            // Return files from memory storage
            const files = this.testStorage.get(customerId) || [];
            console.log(`üîß TEST MODE: Found ${files.length} files in memory for customer ${customerId}`);

            // Return files with original names for display
            return files.map(file => ({
                name: file.originalName || file.name,
                storedName: file.name, // Ïã§Ï†ú Ï†ÄÏû•Îêú ÌååÏùºÎ™Ö
                size: file.size,
                timeCreated: file.timeCreated,
                contentType: file.contentType
            }));
        }

        try {
            console.log(`üìã Listing files for customer: ${customerId}`);
            const bucket = await this.getCustomerBucket(customerId);
            console.log(`üìÅ Bucket retrieved: ${bucket.name}`);

            // List files in customer-specific folder
            const customerFolder = `customer-${customerId}`;
            const [files] = await bucket.getFiles({
                prefix: `${customerFolder}/`
            });
            console.log(`üìÑ Found ${files.length} files in customer folder: ${customerFolder}`);

            const fileList = await Promise.all(files.map(async (file) => {
                try {
                    // Get full metadata for each file
                    const [metadata] = await file.getMetadata();
                    console.log(`üìÑ File metadata for ${file.name}:`, {
                        name: metadata.name,
                        size: metadata.size,
                        contentType: metadata.contentType,
                        timeCreated: metadata.timeCreated,
                        originalName: metadata.metadata?.originalName
                    });

                    // ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏõêÎ≥∏ ÌååÏùºÎ™ÖÏùÑ Í∞ÄÏ†∏ÏôÄÏÑú ÎîîÏΩîÎî©
                    let displayName = file.name; // Í∏∞Î≥∏Í∞íÏùÄ GCS ÌååÏùºÎ™Ö

                    if (metadata.metadata?.originalName) {
                        try {
                            // Ï°∞Í±¥ ÏóÜÏù¥ Ìï≠ÏÉÅ ÎîîÏΩîÎî©ÏùÑ ÏãúÎèÑ (Îã§Íµ≠Ïñ¥ ÏßÄÏõê)
                            const decodedMetadataName = Buffer.from(metadata.metadata.originalName, 'latin1').toString('utf-8');

                            console.log('üîç Decoding check:', {
                                original: metadata.metadata.originalName,
                                decoded: decodedMetadataName,
                                hasKorean: /[Í∞Ä-Ìû£]/.test(decodedMetadataName),
                                hasChinese: /[\u4e00-\u9fff]/.test(decodedMetadataName),
                                hasJapanese: /[\u3040-\u309f\u30a0-\u30ff]/.test(decodedMetadataName),
                                hasCyrillic: /[\u0400-\u04ff]/.test(decodedMetadataName),
                                hasArabic: /[\u0600-\u06ff]/.test(decodedMetadataName)
                            });

                            // ÎîîÏΩîÎî©Îêú Í≤∞Í≥ºÎ•º Ìï≠ÏÉÅ ÏÇ¨Ïö© (Ï°∞Í±¥Î¨∏ Ï†úÍ±∞)
                            displayName = decodedMetadataName;
                            console.log('‚úÖ Using decoded metadata originalName:', decodedMetadataName);

                        } catch (decodeError) {
                            console.warn('‚ö†Ô∏è Failed to decode metadata originalName:', decodeError.message);
                        }
                    }

                    // ÏµúÏ¢Ö displayName ÌôïÏù∏
                    console.log('üîç Final displayName check:', {
                        displayName: displayName,
                        isKorean: /[Í∞Ä-Ìû£]/.test(displayName),
                        isMultilingual: /[Í∞Ä-Ìû£\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\u0400-\u04ff\u0600-\u06ff]/.test(displayName)
                    });

                    console.log(`üìÑ File name processing:`, {
                        gcsFileName: file.name,
                        metadataOriginalName: metadata.metadata?.originalName,
                        decodedMetadataName: metadata.metadata?.originalName ? Buffer.from(metadata.metadata.originalName, 'latin1').toString('utf-8') : null,
                        finalDisplayName: displayName,
                        displayNameType: typeof displayName,
                        displayNameLength: displayName ? displayName.length : 0
                    });

                    return {
                        name: displayName,
                        storedName: file.name, // Ïã§Ï†ú Ï†ÄÏû•Îêú ÌååÏùºÎ™Ö (GCSÏóêÏÑú Í∞ÄÏ†∏Ïò® Ïù¥Î¶Ñ)
                        size: metadata.size,
                        timeCreated: metadata.timeCreated,
                        contentType: metadata.contentType
                    };
                } catch (fileError) {
                    console.error(`‚ùå Error getting metadata for ${file.name}:`, fileError);
                    return {
                        name: file.name,
                        storedName: file.name,
                        size: 0,
                        timeCreated: new Date().toISOString(),
                        contentType: 'application/octet-stream'
                    };
                }
            }));

            console.log(`‚úÖ Successfully processed ${fileList.length} files`);
            return fileList;
        } catch (error) {
            console.error('‚ùå Error listing files:', error);
            console.error('Error details:', {
                customerId,
                errorMessage: error.message,
                errorCode: error.code,
                stack: error.stack
            });
            throw new Error(`Failed to list files: ${error.message}`);
        }
    }

    /**
     * Get file download URL
     */
    async getFileDownloadUrl(customerId, fileName) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Getting download URL for ${fileName}`);
            return `https://test-storage.googleapis.com/test-bucket-${customerId}/${fileName}`;
        }

        try {
            const bucket = await this.getCustomerBucket(customerId);
            const file = bucket.file(fileName);
            const [signedUrl] = await file.getSignedUrl({
                action: 'read',
                expires: Date.now() + 15 * 60 * 1000, // 15 minutes
            });
            return signedUrl;
        } catch (error) {
            console.error('Error getting download URL:', error);
            throw new Error(`Failed to get download URL: ${error.message}`);
        }
    }

    /**
     * Generate AI response using Gemini (Test Mode)
     */
    async generateAIResponse(query, context, customerId) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Generating AI response for customer ${customerId}`);
            return {
                answer: `ÌÖåÏä§Ìä∏ Î™®ÎìúÏóêÏÑú ÏÉùÏÑ±Îêú AI ÏùëÎãµÏûÖÎãàÎã§.\n\nÏßàÎ¨∏: ${query}\n\nÏù¥Í≤ÉÏùÄ Îç∞Î™®Ïö© ÏùëÎãµÏù¥Î©∞, Ïã§Ï†ú Google Cloud ÏÑúÎπÑÏä§Í∞Ä ÏÑ§Ï†ïÎêòÎ©¥ Ï†ïÌôïÌïú AI ÏùëÎãµÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.`,
                references: [
                    {
                        id: 1,
                        name: 'test-document.pdf',
                        score: 0.95,
                        page: 1
                    }
                ]
            };
        }

        // Ïã§Ï†ú Google Cloud AI ÏÑúÎπÑÏä§ Íµ¨ÌòÑÏùÄ Ïó¨Í∏∞Ïóê Ï∂îÍ∞Ä
        throw new Error('Google Cloud AI service not implemented in production mode');
    }

    /**
     * Add document to Discovery Engine data store
     */
    async addDocumentToDataStore(customerId, gcsUri, fileName) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Adding document ${fileName} to data store for customer ${customerId}`);
            console.log(`üîß TEST MODE: GCS URI: ${gcsUri}`);
            return { success: true, message: 'Document added to data store (test mode)' };
        }

        if (!this.documentClient) {
            console.warn(`‚ö†Ô∏è Discovery Engine client not available - skipping document indexing for ${fileName}`);
            return { success: false, message: 'Discovery Engine client not available' };
        }

        try {
            console.log(`üìö Adding document ${fileName} to Discovery Engine data store for customer ${customerId}`);
            console.log(`üìö GCS URI: ${gcsUri}`);

            // Vertex AI SearchÏóê Î¨∏ÏÑú Ïù∏Îç±Ïã± ÏöîÏ≤≠
            const request = {
                parent: this.documentClient.dataStorePath(
                    this.projectId,    // GCP ÌîÑÎ°úÏ†ùÌä∏ ID
                    'global',          // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ†Ïñ¥ ÏúÑÏπò (Î≥¥ÌÜµ global)
                    this.dataStoreId   // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ†Ïñ¥ ID
                ),
                gcsSource: {
                    inputUris: [gcsUri], // Î∞©Í∏à ÏóÖÎ°úÎìúÌïú ÌååÏùºÏùò GCS Í≤ΩÎ°ú
                    dataSchema: 'content',
                },
                // Ï§ëÏöî: Í∏∞Ï°¥ Î¨∏ÏÑúÎäî Í∑∏ÎåÄÎ°ú ÎëêÍ≥† ÏÉàÎ°ú Ï∂îÍ∞ÄÎßå ÌïòÎùºÎäî ÏùòÎØ∏
                reconciliationMode: 'INCREMENTAL',
            };

            console.log(`üìö Starting document import operation for: ${fileName}`);
            console.log(`üìö Data store path: ${request.parent}`);

            // APIÎ•º Ìò∏Ï∂úÌïòÏó¨ Î¨∏ÏÑú Í∞ÄÏ†∏Ïò§Í∏∞(Ïù∏Îç±Ïã±) ÏûëÏóÖÏùÑ ÏãúÏûë
            const [operation] = await this.documentClient.importDocuments(request);
            console.log(`‚úÖ Document import operation started: ${operation.name}`);
            console.log(`‚úÖ Operation metadata:`, operation.metadata);

            // Ïã§Ï†ú ÏûëÏóÖ ÏôÑÎ£åÎ•º Í∏∞Îã§Î¶¥ ÌïÑÏöîÎäî ÏóÜÏäµÎãàÎã§. Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÏßÑÌñâÎê©ÎãàÎã§.
            return {
                success: true,
                message: 'Document indexing started successfully',
                operationName: operation.name,
                fileName: fileName
            };

        } catch (error) {
            console.error('‚ùå Error adding document to Discovery Engine:', error);
            console.error('‚ùå Error details:', {
                message: error.message,
                code: error.code,
                details: error.details
            });

            // Ïù∏Îç±Ïã± Ïã§Ìå®Ìï¥ÎèÑ ÏóÖÎ°úÎìúÎäî ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨ (ÏÇ¨Ïö©Ïûê Í≤ΩÌóò Í≥†Î†§)
            return {
                success: false,
                message: `Document indexing failed: ${error.message}`,
                fileName: fileName
            };
        }
    }

    /**
     * Remove document from Discovery Engine data store
     */
    async removeDocumentFromDataStore(customerId, fileName) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Removing document ${fileName} from data store for customer ${customerId}`);
            return { success: true, message: 'Document removed from data store (test mode)' };
        }

        if (!this.documentClient) {
            console.warn(`‚ö†Ô∏è Discovery Engine client not available - skipping document removal for ${fileName}`);
            return { success: false, message: 'Discovery Engine client not available' };
        }

        try {
            console.log(`üóëÔ∏è Removing document ${fileName} from Discovery Engine data store for customer ${customerId}`);

            // ÌååÏùºÎ™ÖÏóêÏÑú Î¨∏ÏÑú ID Ï∂îÏ∂ú (ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Î∂ÄÎ∂Ñ)
            const timestampMatch = fileName.match(/(\d+)-[a-z0-9]+-/);
            if (!timestampMatch) {
                console.warn(`‚ö†Ô∏è Could not extract document ID from filename: ${fileName}`);
                return { success: false, message: 'Could not extract document ID from filename' };
            }

            const documentId = timestampMatch[1];
            console.log(`üóëÔ∏è Extracted document ID: ${documentId}`);

            // Î¨∏ÏÑú ÏÇ≠Ï†ú ÏöîÏ≤≠
            const request = {
                name: this.documentClient.documentPath(
                    this.projectId,    // GCP ÌîÑÎ°úÏ†ùÌä∏ ID
                    'global',          // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ†Ïñ¥ ÏúÑÏπò
                    this.dataStoreId,  // Îç∞Ïù¥ÌÑ∞ Ïä§ÌÜ†Ïñ¥ ID
                    documentId         // Î¨∏ÏÑú ID
                ),
            };

            console.log(`üóëÔ∏è Deleting document: ${request.name}`);
            await this.documentClient.deleteDocument(request);

            console.log(`‚úÖ Document successfully removed from Discovery Engine: ${fileName}`);
            return {
                success: true,
                message: 'Document removed from data store successfully',
                fileName: fileName
            };

        } catch (error) {
            console.error('‚ùå Error removing document from Discovery Engine:', error);
            console.error('‚ùå Error details:', {
                message: error.message,
                code: error.code,
                details: error.details
            });

            // ÏÇ≠Ï†ú Ïã§Ìå®Ìï¥ÎèÑ ÌååÏùº ÏÇ≠Ï†úÎäî ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨ (ÏÇ¨Ïö©Ïûê Í≤ΩÌóò Í≥†Î†§)
            return {
                success: false,
                message: `Document removal from data store failed: ${error.message}`,
                fileName: fileName
            };
        }
    }

    /**
     * Search documents using Vertex AI Search
     */
    async searchDocuments(customerId, query, maxResults = 5) {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Searching documents for customer ${customerId}`);
            return [
                {
                    title: 'ÌÖåÏä§Ìä∏ Î¨∏ÏÑú',
                    content: 'ÌÖåÏä§Ìä∏ Î¨∏ÏÑúÏóêÏÑú Ï∞æÏùÄ Í¥ÄÎ†® ÎÇ¥Ïö©ÏûÖÎãàÎã§. Ïã§Ï†ú Vertex AI SearchÍ∞Ä Ïó∞Í≤∞ÎêòÎ©¥ Îçî Ï†ïÌôïÌïú Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§.',
                    uri: 'gs://test-bucket/test-document.pdf',
                    score: 0.95
                }
            ];
        }

        try {
            console.log(`üîç Searching documents for customer ${customerId} with query: ${query}`);

            // TODO: Ïã§Ï†ú Vertex AI Search API Ìò∏Ï∂ú Íµ¨ÌòÑ
            // ÌòÑÏû¨Îäî ÌîÑÎ°úÎçïÏÖò Î™®ÎìúÏóêÏÑúÎèÑ ÌÖåÏä§Ìä∏ ÏùëÎãµ Î∞òÌôò
            console.log('‚ö†Ô∏è Vertex AI Search not fully implemented yet, returning test response');

            return [
                {
                    title: 'ÌîÑÎ°úÎçïÏÖò ÌÖåÏä§Ìä∏ Î¨∏ÏÑú',
                    content: `ÌîÑÎ°úÎçïÏÖò Î™®ÎìúÏóêÏÑú "${query}"Ïóê ÎåÄÌïú Í≤ÄÏÉâ Í≤∞Í≥ºÏûÖÎãàÎã§. Vertex AI SearchÍ∞Ä ÏôÑÏ†ÑÌûà Íµ¨ÌòÑÎêòÎ©¥ Ïã§Ï†ú Î¨∏ÏÑúÏóêÏÑú Í≤ÄÏÉâÎêú ÎÇ¥Ïö©ÏùÑ Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§.`,
                    uri: 'gs://toads-bucket/production-test-document.pdf',
                    score: 0.90
                }
            ];
        } catch (error) {
            console.error('Error searching documents:', error);
            throw new Error(`Failed to search documents: ${error.message}`);
        }
    }

    /**
     * Generate AI response using Vertex AI with system prompt
     */
    async generateAIResponse(query, searchResults, customerId, companyName = 'ÌÜ†Ï¶à') {
        if (this.isTestMode) {
            console.log(`üîß TEST MODE: Generating AI response for customer ${customerId}`);

            // ÌÖåÏä§Ìä∏ Î™®ÎìúÏóêÏÑúÎèÑ ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ Íµ¨Ï°∞ ÏÇ¨Ïö©
            const contextInfo = searchResults.map((result, index) =>
                `${index + 1}. ${result.title}: ${result.content.substring(0, 200)}...`
            ).join('\n');

            const systemPrompt = generateSystemPrompt(
                companyName, // ÎèôÏ†Å Í≥†Í∞ùÏÇ¨Î™Ö
                contextInfo,
                query
            );

            console.log('üìù Generated system prompt for test mode');
            console.log('System prompt preview:', systemPrompt.substring(0, 500) + '...');

            return `ÌÖåÏä§Ìä∏ Î™®Îìú: "${query}"Ïóê ÎåÄÌïú AI ÏùëÎãµÏûÖÎãàÎã§.\n\nÍ≤ÄÏÉâÎêú Î¨∏ÏÑú ${searchResults.length}Í∞úÎ•º Ï∞∏Í≥†ÌïòÏó¨ ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±ÌñàÏäµÎãàÎã§.\n\nÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏Í∞Ä Ï†ÅÏö©ÎêòÏñ¥ Ïã§Ï†ú Vertex AI Ïó∞Í≤∞ Ïãú Ï†ÑÎ¨∏Ï†ÅÏù∏ ÎãµÎ≥ÄÏùÑ Ï†úÍ≥µÌï† Ïàò ÏûàÏäµÎãàÎã§.`;
        }

        if (!this.vertexAI) {
            console.warn('‚ö†Ô∏è Vertex AI client not available - returning fallback response');
            return `Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÌòÑÏû¨ AI ÏÑúÎπÑÏä§Í∞Ä ÏùºÏãúÏ†ÅÏúºÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.`;
        }

        try {
            console.log(`ü§ñ Generating AI response for customer ${customerId} with ${searchResults.length} search results`);

            // Í≤ÄÏÉâ Í≤∞Í≥ºÎ•º Ïª®ÌÖçÏä§Ìä∏Î°ú Î≥ÄÌôò
            const contextInfo = searchResults.map((result, index) =>
                `Î¨∏ÏÑú ${index + 1}: ${result.title}\nÎÇ¥Ïö©: ${result.content}\nÏ∂úÏ≤ò: ${result.uri}\nÏ†êÏàò: ${result.score}\n---`
            ).join('\n');

            // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
            const systemPrompt = generateSystemPrompt(
                companyName, // ÎèôÏ†Å Í≥†Í∞ùÏÇ¨Î™Ö
                contextInfo,
                query
            );

            console.log('üìù Generated system prompt for production mode');
            console.log('System prompt length:', systemPrompt.length);

            // Ïã§Ï†ú Vertex AI API Ìò∏Ï∂ú
            const generativeModel = this.vertexAI.getGenerativeModel({
                model: 'gemini-1.5-pro',
                generationConfig: {
                    maxOutputTokens: 2048,
                    temperature: 0.7,
                    topP: 0.8,
                    topK: 40
                }
            });

            console.log('üöÄ Calling Vertex AI API...');
            const result = await generativeModel.generateContent(systemPrompt);
            const response = result.response;

            if (response.candidates && response.candidates.length > 0) {
                const aiResponse = response.candidates[0].content.parts[0].text;
                console.log('‚úÖ Vertex AI response generated successfully');
                console.log('Response length:', aiResponse.length);
                return aiResponse;
            } else {
                console.warn('‚ö†Ô∏è No candidates in Vertex AI response');
                return `Ï£ÑÏÜ°Ìï©ÎãàÎã§. AI ÏùëÎãµÏùÑ ÏÉùÏÑ±ÌïòÎäî Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.`;
            }

        } catch (error) {
            console.error('‚ùå Error generating AI response:', error);
            console.error('‚ùå Error details:', {
                message: error.message,
                code: error.code,
                details: error.details
            });

            // AI ÏùëÎãµ ÏÉùÏÑ± Ïã§Ìå® Ïãú fallback ÏùëÎãµ
            return `Ï£ÑÏÜ°Ìï©ÎãàÎã§. AI ÏùëÎãµÏùÑ ÏÉùÏÑ±ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.\n\nÏò§Î•ò: ${error.message}`;
        }
    }
}

module.exports = new GoogleCloudService();